# 将cache集成到CPU中
1. Cache 模块功能边界划分
CPU 流水线向 Cache 模块发送请求，Cache 模块给 CPU 流水线返回数据或是写成功的响应。
还需要 CPU 中的 TLB 模块将转换后的物理地址送到 Cache 模块中，Cache 模块将该物理地址寄存一拍，然后用于 Cache Tag 比较。
2. AXI 总线接口模块要进行调整

3. Cache 命中情况下的 CPU 流水线适配
需要保证 Cache 命中情况下的数据读出也只要花费两个时钟周期。
* 对于指令 Cache 的 Look Up 访问，其请求由 pre-IF 级发来，返回的结果送至 IF 级；
* addr_ok 没有拉高时，证明Cache被阻塞，要阻塞流水线。
* 在集成 Cache 模块的时候，要务必确保 pre-IF 级和 EX 级发往 Cache 模块的读写类型和地址信号中没有组合逻辑引入 Cache 模块传过来的 addr_ok 信号，否则会导致组合环路.

4. Cache 未命中情况下的 CPU 流水线适配
* 还是通过 addr_ok 这个信号完成控制
* 对于读操作来说，如果 Cache 缺失，那么相应的指令需要在流水线中等待结果返回，这是通过 Cache 模块的 data_ok 输出信号来保证的。其原理与设计总线接口时 data_ok 信号对流水线的控制是一样的，这里就不再解释了。

5. 存储访问类型的判定
直接地址翻译模式下：
    取指的存储访问类型由 CSR.CRMD 的 DATF 域决定，
    load/store 指令访存的存储访问类型由 CSR.CRMD 的 DATM 域决定；
直接映射地址翻译模式下：
    取指或访存的存储访问类型由所命中的直接映射窗口中 MAT 配置信息（来自于 CSR.DMW0/1的 MAT 域）决定；
页表映射地址翻译模式下：
    取指或访存的存储访问类型则是由虚实地址转换所用页表项中的 MAT 域配置信息决定。

6. 在 Cache 模块中处理非缓存访问
1）所有发往 Cache 模块的访存请求要能够区分是可缓存还是非缓存，因此需要在 Cache 模块的接口增加 1 比特信号指示当前请求的存储访问类型。
2）非缓存访问在 Cache 模块的实现应尽可能地复用 Cache Miss 的处理流程和数据通路。

任务：
1. 在主模块中实例化Cache
2. 在bridge中实现读Burst功能：如果输入的inst_sram_size=100时，令arsize=10,并且将arlen转换为4，即读取16byte。然后接下来的四个周期每周期读取到的数据进行发送。


bug:
1. 在突发传输时，bridge中的len信号设置成了4，但是4应该对应的是5拍，因此导致出错。

现象：流水线一直被阻塞在一个地方。
2. 出现了一个ertn指令，但是此ertn指令的返回地址是一个不对齐地址，此时出现错误。
错误原因：由于ertn指令会清空流水线，之前为了防止清空流水线时已经发给cache和内存的一个指令返回后又继续向后传递，设计了一个data_ok_cancel信号，这个信号会等待已经发出去的指令返回后再继续向后传递，这样就能保证会取消掉错误发出的指令。
但是在ertn指令清空流水线时，ertn PC+4 对应的错误发出了一个指令，但是由于cache burst请求需要耗费4个周期进行返回，在burst期间会阻塞新的读请求到来，又因为阻塞时cache并未降这个读请求存储下来，因此当这个指令还被阻塞的时候，ertn已经清空流水线，将IF阶段发出的PC信号转变为一个不对齐地址，导致这个错误发出的指令其实并未被cache收到，因此cache也就不会再返回data_ok信号，进而导致流水线一直被阻塞。

设计如下逻辑：当跳转或者异常时，将这个信号存储下来，并且判断cache访问是否返回，如果返回了，那么就将这个信号清空，如果没有返回，那么就将这个信号保留，直到返回后再清空。







